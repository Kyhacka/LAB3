open System


let getStringLengths (strSeq: seq<string>) =
    strSeq |> Seq.map (fun s -> 
        printfn "[ВЫЧИСЛЕНИЕ] Обрабатываю строку: '%s'" s  // Это сработает только при реальном вычислении
        s.Length)

let inputStrings (count: int) =
    let mutable strings = []
    let mutable remaining = count

    while remaining > 0 do
        printfn "Введите строку (осталось ввести %d строк):" remaining
        let input = Console.ReadLine()
        strings <- input :: strings
        remaining <- remaining - 1

    List.rev strings

let rec inputPositiveNumber prompt =
    printfn "%s" prompt
    match Int32.TryParse(Console.ReadLine()) with
    | true, value when value > 0 -> value
    | _ -> 
        printfn "Некорректный ввод. Пожалуйста, введите положительное число."
        inputPositiveNumber prompt

[<EntryPoint>]
let main argv =
    let count = inputPositiveNumber "Введите количество строк (положительное число):"
    let strings = inputStrings count

    printfn "\n[ЭТАП 1] Создаем отложенное вычисление (ничего не вычисляется!)"
    let lengthsSeq = getStringLengths strings  // Здесь только создается "обещание" вычислить
    
    printfn "\n[ЭТАП 2] Отложенное вычисление создано, но сообщений выше нет"
    printfn "         (значит, никакие строки еще не обрабатывались)\n"

    printfn "[ЭТАП 3] Материализуем последовательность в список (вычисления происходят сейчас!):"
    let lengthsList = lengthsSeq |> List.ofSeq  // Вот здесь реально вычисляются длины
    
    printfn "\n[ЭТАП 4] Результат:"
    printfn "Исходные строки: %A" strings
    printfn "Длины строк: %A" lengthsList

    0
